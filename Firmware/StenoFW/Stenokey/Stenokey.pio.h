// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------------ //
// read_key_col //
// ------------ //

#define read_key_col_wrap_target 0
#define read_key_col_wrap 14

#define read_key_col_COLS 10

static const uint16_t read_key_col_program_instructions[] = {
            //     .wrap_target
    0xc030, //  0: irq    wait 0 rel                 
    0xe022, //  1: set    x, 2                       
    0xa0e1, //  2: mov    osr, x                     
    0x6081, //  3: out    pindirs, 1                 
    0xf001, //  4: set    pins, 1         side 0     
    0x400a, //  5: in     pins, 10                   
    0xf800, //  6: set    pins, 0         side 1     
    0x400a, //  7: in     pins, 10                   
    0x6081, //  8: out    pindirs, 1                 
    0xe001, //  9: set    pins, 1                    
    0x6001, // 10: out    pins, 1                    
    0xc051, // 11: irq    clear 1 rel                
    0xa026, // 12: mov    x, isr                     
    0x002f, // 13: jmp    !x, 15                     
    0x8020, // 14: push   block                      
            //     .wrap
    0x0000, // 15: jmp    0                          
};

#if !PICO_NO_HARDWARE
static const struct pio_program read_key_col_program = {
    .instructions = read_key_col_program_instructions,
    .length = 16,
    .origin = -1,
};

static inline pio_sm_config read_key_col_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + read_key_col_wrap_target, offset + read_key_col_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}
#endif

// ------------------- //
// read_key_col_repeat //
// ------------------- //

#define read_key_col_repeat_wrap_target 0
#define read_key_col_repeat_wrap 14

#define read_key_col_repeat_COLS 10

static const uint16_t read_key_col_repeat_program_instructions[] = {
            //     .wrap_target
    0xc031, //  0: irq    wait 1 rel                 
    0xe022, //  1: set    x, 2                       
    0xa0e1, //  2: mov    osr, x                     
    0x6081, //  3: out    pindirs, 1                 
    0xf001, //  4: set    pins, 1         side 0     
    0x400a, //  5: in     pins, 10                   
    0xf800, //  6: set    pins, 0         side 1     
    0x400a, //  7: in     pins, 10                   
    0x6081, //  8: out    pindirs, 1                 
    0xe001, //  9: set    pins, 1                    
    0x6001, // 10: out    pins, 1                    
    0xc052, // 11: irq    clear 2 rel                
    0xa026, // 12: mov    x, isr                     
    0x002f, // 13: jmp    !x, 15                     
    0x8020, // 14: push   block                      
            //     .wrap
    0x0000, // 15: jmp    0                          
};

#if !PICO_NO_HARDWARE
static const struct pio_program read_key_col_repeat_program = {
    .instructions = read_key_col_repeat_program_instructions,
    .length = 16,
    .origin = -1,
};

static inline pio_sm_config read_key_col_repeat_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + read_key_col_repeat_wrap_target, offset + read_key_col_repeat_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}
#endif

// ------------------ //
// read_key_row_first //
// ------------------ //

#define read_key_row_first_wrap_target 0
#define read_key_row_first_wrap 14

#define read_key_row_first_ROWS 4
#define read_key_row_first_pio 0

static const uint16_t read_key_row_first_program_instructions[] = {
            //     .wrap_target
    0xc030, //  0: irq    wait 0 rel                 
    0xe022, //  1: set    x, 2                       
    0xa0e1, //  2: mov    osr, x                     
    0x6081, //  3: out    pindirs, 1                 
    0xf001, //  4: set    pins, 1         side 0     
    0x4004, //  5: in     pins, 4                    
    0xf800, //  6: set    pins, 0         side 1     
    0x4004, //  7: in     pins, 4                    
    0x6081, //  8: out    pindirs, 1                 
    0xe001, //  9: set    pins, 1                    
    0x6001, // 10: out    pins, 1                    
    0xc051, // 11: irq    clear 1 rel                
    0xa026, // 12: mov    x, isr                     
    0x002f, // 13: jmp    !x, 15                     
    0x8020, // 14: push   block                      
            //     .wrap
    0x0000, // 15: jmp    0                          
};

#if !PICO_NO_HARDWARE
static const struct pio_program read_key_row_first_program = {
    .instructions = read_key_row_first_program_instructions,
    .length = 16,
    .origin = -1,
};

static inline pio_sm_config read_key_row_first_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + read_key_row_first_wrap_target, offset + read_key_row_first_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}
#endif

// ------------------- //
// read_key_row_second //
// ------------------- //

#define read_key_row_second_wrap_target 0
#define read_key_row_second_wrap 14

#define read_key_row_second_ROWS 4
#define read_key_row_second_pio 0

static const uint16_t read_key_row_second_program_instructions[] = {
            //     .wrap_target
    0xc030, //  0: irq    wait 0 rel                 
    0xe022, //  1: set    x, 2                       
    0xa0e1, //  2: mov    osr, x                     
    0x6081, //  3: out    pindirs, 1                 
    0xf001, //  4: set    pins, 1         side 0     
    0x4004, //  5: in     pins, 4                    
    0xf800, //  6: set    pins, 0         side 1     
    0x4004, //  7: in     pins, 4                    
    0x6081, //  8: out    pindirs, 1                 
    0xe001, //  9: set    pins, 1                    
    0x6001, // 10: out    pins, 1                    
    0xc040, // 11: irq    clear 0                    
    0xa026, // 12: mov    x, isr                     
    0x002f, // 13: jmp    !x, 15                     
    0x8020, // 14: push   block                      
            //     .wrap
    0x0000, // 15: jmp    0                          
};

#if !PICO_NO_HARDWARE
static const struct pio_program read_key_row_second_program = {
    .instructions = read_key_row_second_program_instructions,
    .length = 16,
    .origin = -1,
};

static inline pio_sm_config read_key_row_second_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + read_key_row_second_wrap_target, offset + read_key_row_second_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}

    //second write pin is always consecutive so we dont need to pass that in
    static inline void read_key_row_first(PIO pio, uint sm, uint offset, uint startReadPin, uint endReadPin, uint writePin){
        for (int i=startReadPin; i<startReadPin+endReadPin; i++){
            pio_gpio_init(pio, i);
            gpio_pull_up(i);//this should be fine for output just another Vcc on the line
            gpio_set_input_hysteresis_enabled(i,0); //disable schmitt trigger to catch pulses as signal
            gpio_set_slew_rate(i, 1); //set 1 clock slew NOTE: this and schmitt disable may cause instability
            //NOTE: may need to change drive strength since brown out can occur when writting all columns high
        }
        pio_sm_config c = read_key_row_first_program_get_default_config(offset);
        sm_config_set_in_shift(&c, true, false, 2*read_key_row_first_ROWS);
        sm_config_set_set_pins(&c, writePin+1, 1); //first address
        sm_config_set_sideset_pins(&c, writePin); //second address
        sm_config_set_out_pins(&c, startReadPin, endReadPin); //read pins
        pio_sm_set_in_pins(pio, sm, startReadPin); //read pins
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
        pio_sm_init(pio,sm,offset,&c);
        pio_sm_set_enabled(pio,sm,true);
    }
    static inline void read_key_row_second(PIO pio, uint sm, uint offset, uint startReadPin, uint endReadPin, uint writePin){
        for (int i=startReadPin; i<startReadPin+endReadPin; i++){
            pio_gpio_init(pio, i);
            gpio_pull_up(i);//this should be fine for output just another Vcc on the line
            gpio_set_input_hysteresis_enabled(i,0); //disable schmitt trigger to catch pulses as signal
            gpio_set_slew_rate(i, 1); //set 1 clock slew NOTE: this and schmitt disable may cause instability
            //NOTE: may need to change drive strength since brown out can occur when writting all columns high
        }
        pio_sm_config c = read_key_row_second_program_get_default_config(offset);
        sm_config_set_in_shift(&c, true, false, 2*read_key_row_second_ROWS);
        sm_config_set_set_pins(&c, writePin+1, 1); //first address
        sm_config_set_sideset_pins(&c, writePin); //second address
        sm_config_set_out_pins(&c, startReadPin, endReadPin); //read pins
        pio_sm_set_in_pins(pio, sm, startReadPin); //read pins
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
        //DMA configurations:
        //endReadPin
        //sm+pio_get_index(pio)
        pio_sm_init(pio,sm,offset,&c);
        pio_sm_set_enabled(pio,sm,true);
    }
    static inline void read_key_col(PIO pio, uint sm, uint offset, uint startReadPin, uint endReadPin, uint writePin){
        for (int i=startReadPin; i<startReadPin+endReadPin; i++){
            pio_gpio_init(pio, i);
            gpio_pull_up(i);//this should be fine for output just another Vcc on the line
            //disable schmitt trigger to catch lower order pulses as signal
            //this is moreover a trigger threshold hack
            gpio_set_input_hysteresis_enabled(i,0);
            gpio_set_slew_rate(i, 1); //set 1 clock slew NOTE: this and schmitt disable may cause instability
            //NOTE: may need to change drive strength since brown out can occur when writting all columns high
        }
        pio_sm_config c = read_key_col_program_get_default_config(offset);
        sm_config_set_in_shift(&c, true, false, 16);
        sm_config_set_set_pins(&c, writePin+1, 1); //first address
        sm_config_set_sideset_pins(&c, writePin); //second address
        sm_config_set_out_pins(&c, startReadPin, endReadPin); //read pins
        pio_sm_set_in_pins(pio, sm, startReadPin); //read pins
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
        pio_sm_init(pio,sm,offset,&c);
        pio_sm_set_enabled(pio,sm,true);
    }
    static inline void read_key_col_repeat(PIO pio, uint sm, uint offset, uint startReadPin, uint endReadPin, uint writePin){
        for (int i=startReadPin; i<startReadPin+endReadPin; i++){
            pio_gpio_init(pio, i);
            gpio_pull_up(i);//this should be fine for output just another Vcc on the line
            //disable schmitt trigger to catch lower order pulses as signal
            //this is moreover a trigger threshold hack
            gpio_set_input_hysteresis_enabled(i,0);
            //set 1 clock slew NOTE: this and schmitt disable may cause instability and induction/false positives and negative
            //(line induction? lines are not even and likely geometric)
            gpio_set_slew_rate(i, 1);
            //NOTE: may need to change drive strength since brown out can occur when writting all columns high
            //      || rapid slew may need overvoltage for Tau
            //all of this should be resolvable in this configuration
        }
        pio_sm_config c = read_key_col_repeat_program_get_default_config(offset);
        //sm_config_set_in_shift(&c, true, false, 2*read_key_col_repeat_COLS);
        sm_config_set_in_shift(&c, true, false, 16);
        sm_config_set_set_pins(&c, writePin+1, 1); //first address
        sm_config_set_sideset_pins(&c, writePin); //second address
        sm_config_set_out_pins(&c, startReadPin, endReadPin); //read pins
        pio_sm_set_in_pins(pio, sm, startReadPin); //read pins
        sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
        pio_sm_init(pio,sm,offset,&c);
        pio_sm_set_enabled(pio,sm,true);
    }

#endif

